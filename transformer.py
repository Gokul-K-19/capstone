# -*- coding: utf-8 -*-
"""Transformer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mpWs--Z_3vscpLjIzH29GdtPnuZD7Lo3
"""

# ======================================================
# 1Ô∏è‚É£ Imports
# ======================================================
import tensorflow as tf
import numpy as np
import pandas as pd
import time
import os

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

print("TensorFlow version:", tf.__version__)

# ======================================================
# 2Ô∏è‚É£ Upload & Load Dataset
# ======================================================

from google.colab import files
uploaded = files.upload()

df = pd.read_csv("basic_augmented_dataset.csv")

print("\nColumns:", df.columns)
print("Dataset shape:", df.shape)

# ======================================================
# 3Ô∏è‚É£ Encode Gender (M/F ‚Üí 0/1)
# ======================================================

if df["GENDER"].dtype == "object":
    df["GENDER"] = df["GENDER"].map({"M": 0, "F": 1})

# ======================================================
# 4Ô∏è‚É£ Separate Features & Target
# ======================================================

X = df.drop(columns=["GLUCOSE_LEVEL"])
y = df["GLUCOSE_LEVEL"].values.reshape(-1,1)

print("\nSamples:", X.shape[0])
print("Features:", X.shape[1])

# ======================================================
# 5Ô∏è‚É£ Train-Test Split + Scaling
# ======================================================

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# ======================================================
# 6Ô∏è‚É£ Build Optimized MLP Model
# Architecture: 4 ‚Üí 32 ‚Üí 16 ‚Üí 1
# ======================================================

inputs = tf.keras.Input(shape=(4,))

x = tf.keras.layers.Dense(32)(inputs)
x = tf.keras.layers.Reshape((4, 8))(x)  # 4 tokens, 8-dim each

attn = tf.keras.layers.MultiHeadAttention(
    num_heads=2,
    key_dim=8
)(x, x)

x = tf.keras.layers.Flatten()(attn)
x = tf.keras.layers.Dense(32, activation='relu')(x)
outputs = tf.keras.layers.Dense(1)(x)

model = tf.keras.Model(inputs, outputs)
model.compile(optimizer='adam', loss='mse')

model.summary()

# ======================================================
# 7Ô∏è‚É£ Train Model + Measure Time
# ======================================================

start_time = time.time()
model.fit(X_train, y_train, epochs=80, batch_size=32, verbose=1)
training_time = time.time() - start_time

print("\nTraining Time:", round(training_time,2), "seconds")

# ======================================================
# 8Ô∏è‚É£ Evaluate Float Model
# ======================================================

y_pred = model.predict(X_test)

mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
r2 = r2_score(y_test, y_pred)

print("\nFLOAT MODEL PERFORMANCE")
print("MAE:", mae)
print("RMSE:", rmse)
print("R2:", r2)

# ======================================================
# 9Ô∏è‚É£ Save Float Model & Check Size
# ======================================================

model.save("float_model.h5")
float_size = os.path.getsize("float_model.h5") / 1024
print("\nFloat Model Size:", round(float_size,2), "KB")

# ======================================================
# üîü INT8 Quantization
# ======================================================

def representative_dataset():
    for i in range(min(100, len(X_train))):
        yield [X_train[i:i+1].astype(np.float32)]

converter = tf.lite.TFLiteConverter.from_keras_model(model)
converter.optimizations = [tf.lite.Optimize.DEFAULT]
converter.representative_dataset = representative_dataset
converter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS_INT8]
converter.inference_input_type = tf.int8
converter.inference_output_type = tf.int8

tflite_model = converter.convert()

with open("quant_model.tflite", "wb") as f:
    f.write(tflite_model)

quant_size = os.path.getsize("quant_model.tflite") / 1024
print("\nQuantized Model Size:", round(quant_size,2), "KB")

# ======================================================
# 1Ô∏è‚É£1Ô∏è‚É£ Evaluate Quantized Model
# ======================================================

interpreter = tf.lite.Interpreter(model_path="quant_model.tflite")
interpreter.allocate_tensors()

input_details = interpreter.get_input_details()
output_details = interpreter.get_output_details()

input_scale, input_zero_point = input_details[0]['quantization']
output_scale, output_zero_point = output_details[0]['quantization']

y_pred_quant = []
start_time = time.time()

for i in range(len(X_test)):
    x = X_test[i:i+1]

    x_quant = (x / input_scale + input_zero_point).astype(np.int8)

    interpreter.set_tensor(input_details[0]['index'], x_quant)
    interpreter.invoke()

    output = interpreter.get_tensor(output_details[0]['index'])
    output = (output.astype(np.float32) - output_zero_point) * output_scale

    y_pred_quant.append(output[0][0])

quant_time = time.time() - start_time

y_pred_quant = np.array(y_pred_quant).reshape(-1,1)

mae_q = mean_absolute_error(y_test, y_pred_quant)
rmse_q = np.sqrt(mean_squared_error(y_test, y_pred_quant))
r2_q = r2_score(y_test, y_pred_quant)

print("\nQUANTIZED MODEL PERFORMANCE")
print("MAE:", mae_q)
print("RMSE:", rmse_q)
print("R2:", r2_q)
print("Quantized Inference Time:", round(quant_time,2), "seconds")

